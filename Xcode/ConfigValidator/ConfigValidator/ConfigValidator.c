#if 0
      CloverConfigPlistValidator, Credit: Jief_Machak
      ConfigValidator, Credit: chris1111
      shc Version 3.8.9b, Copyright (c) 1994-2015 Francisco Rosales

#endif

static  char data [] =
#define      msg2_z    19
#define      msg2    ((&data[1]))
    "\241\107\113\341\074\016\206\324\220\023\352\253\015\010\112\020"
    "\266\245\254\364\057"
#define      shll_z    8
#define      shll    ((&data[22]))
    "\235\130\070\333\001\150\257\256\343\175"
#define      opts_z    1
#define      opts    ((&data[31]))
    "\243"
#define      xecc_z    15
#define      xecc    ((&data[34]))
    "\015\136\214\036\330\273\162\301\256\002\210\024\154\066\204\110"
    "\123\240\116"
#define      rlax_z    1
#define      rlax    ((&data[51]))
    "\075"
#define      chk1_z    22
#define      chk1    ((&data[55]))
    "\321\151\146\001\230\354\254\316\226\030\263\135\033\362\307\340"
    "\124\356\035\315\021\271\353\126\217\205\376\033\376\311"
#define      lsto_z    1
#define      lsto    ((&data[82]))
    "\270"
#define      pswd_z    256
#define      pswd    ((&data[96]))
    "\025\054\034\075\164\225\237\300\174\150\142\021\371\017\133\300"
    "\220\214\345\177\240\335\162\244\336\306\331\244\042\315\011\310"
    "\354\234\050\312\261\046\057\125\230\266\270\142\251\375\044\142"
    "\051\133\375\310\264\274\201\230\044\056\372\072\023\135\221\270"
    "\330\257\261\121\337\226\133\072\375\242\075\206\334\031\235\072"
    "\122\334\216\236\367\350\264\355\232\010\307\315\357\014\051\134"
    "\134\362\347\325\022\077\231\124\141\313\153\167\242\327\021\121"
    "\072\077\216\172\042\142\346\312\266\045\377\040\150\301\364\140"
    "\165\206\373\273\057\025\117\337\146\045\113\336\202\113\200\064"
    "\221\225\165\102\046\331\014\204\045\106\353\167\055\275\314\221"
    "\163\355\050\342\352\333\145\060\210\025\147\012\115\043\047\340"
    "\253\354\204\374\223\314\110\152\320\352\320\141\366\217\313\275"
    "\323\012\160\043\337\237\376\057\254\013\337\140\055\200\334\334"
    "\116\346\041\003\317\001\250\041\132\164\313\363\130\073\210\047"
    "\007\311\160\111\316\061\371\245\306\175\331\120\167\210\244\336"
    "\272\200\007\156\234\243\343\261\235\306\301\317\050\150\275\261"
    "\017\204\217\221\336\273\124\365\110\333\132\336\307\003\035\377"
    "\007\063\237\131\114\123\320\103\301\227\117\120\273\264\342\126"
    "\143\033\142\231\342\211\031\326\252\007\176\055\121\255\321\216"
    "\015"
#define      chk2_z    19
#define      chk2    ((&data[392]))
    "\240\327\130\125\110\271\002\037\063\066\330\023\121\327\056\220"
    "\114\242\331\332\276\216\264"
#define      text_z    905
#define      text    ((&data[539]))
    "\253\345\007\141\174\054\316\143\103\146\303\373\101\205\255\073"
    "\207\140\243\000\356\230\357\152\122\007\112\326\374\252\066\200"
    "\307\040\135\376\331\376\267\270\222\325\017\376\035\264\254\362"
    "\363\107\211\051\140\201\113\006\317\037\305\102\362\350\365\057"
    "\326\105\016\163\205\005\147\075\372\146\137\321\125\327\104\021"
    "\114\241\263\354\333\112\364\004\250\377\335\111\253\151\303\237"
    "\077\245\367\320\020\345\055\367\150\057\142\072\050\220\150\357"
    "\145\127\204\252\112\154\146\247\161\177\006\335\045\341\047\165"
    "\312\247\073\234\122\301\031\367\372\207\042\205\116\211\102\057"
    "\341\052\201\162\134\070\350\006\211\227\122\073\323\310\372\357"
    "\244\272\232\324\124\001\005\102\325\060\212\067\020\317\252\265"
    "\111\226\124\344\144\123\320\335\174\157\270\320\322\055\161\010"
    "\227\306\132\326\061\021\112\227\324\357\247\251\054\161\340\071"
    "\061\137\342\034\066\264\134\150\225\252\165\005\273\127\233\361"
    "\304\002\005\156\224\364\000\153\130\175\233\276\371\205\065\365"
    "\215\271\103\120\260\116\060\275\221\334\067\303\324\036\316\150"
    "\316\225\157\062\272\067\341\321\025\334\042\167\010\313\314\202"
    "\147\102\267\076\334\065\221\113\074\322\300\276\104\113\361\362"
    "\155\334\362\032\335\177\331\215\060\234\163\164\165\341\063\101"
    "\301\076\202\325\006\212\274\132\222\133\272\352\322\306\145\325"
    "\321\142\233\130\204\226\143\041\244\356\045\155\305\355\322\176"
    "\242\056\020\250\225\332\165\346\225\231\171\375\354\303\162\206"
    "\341\201\377\141\151\010\245\153\133\337\342\322\251\225\117\071"
    "\005\164\016\225\351\263\216\350\167\201\222\122\162\153\003\273"
    "\300\065\156\130\113\310\246\253\071\365\261\262\136\101\013\032"
    "\212\131\363\353\077\234\220\176\360\044\242\151\360\064\314\072"
    "\124\340\005\104\320\124\006\162\164\335\252\274\044\251\017\107"
    "\313\074\001\077\205\234\107\241\037\326\355\015\303\160\355\137"
    "\110\026\000\015\221\176\207\047\336\267\315\167\375\313\020\027"
    "\137\151\020\032\334\270\223\354\176\110\324\072\254\006\313\142"
    "\300\057\320\037\063\057\216\021\333\350\037\362\370\167\275\276"
    "\061\301\063\207\213\270\354\305\140\325\155\313\260\266\301\136"
    "\323\316\000\051\334\054\023\317\040\356\112\261\254\115\166\247"
    "\146\216\073\073\147\224\317\253\322\030\064\144\116\253\126\255"
    "\214\324\340\107\021\203\204\271\154\261\306\246\275\352\056\247"
    "\331\317\305\270\067\135\272\361\251\116\145\226\217\145\175\223"
    "\277\153\123\232\021\211\157\377\133\020\077\007\025\075\316\144"
    "\043\313\131\157\117\227\347\220\336\071\054\164\345\014\262\012"
    "\211\067\176\024\222\117\145\332\131\062\176\152\145\063\025\264"
    "\310\025\131\312\275\275\100\163\252\015\016\344\212\335\343\324"
    "\365\053\124\211\003\241\137\221\326\242\307\206\137\144\103\324"
    "\313\157\016\367\127\132\016\246\357\055\204\343\352\251\244\245"
    "\010\121\040\353\171\140\121\315\274\204\127\234\335\352\302\226"
    "\053\135\225\003\315\070\342\126\165\032\204\313\255\106\064\344"
    "\170\172\250\201\165\067\042\377\241\201\125\311\261\153\120\161"
    "\124\235\250\240\041\077\335\343\301\042\141\322\114\311\245\054"
    "\150\034\134\316\134\313\327\025\312\060\337\250\326\305\201\261"
    "\214\370\141\256\232\353\065\234\304\132\103\300\234\135\170\255"
    "\265\237\171\362\334\225\263\144\157\241\107\157\065\345\361\111"
    "\252\151\301\351\116\026\240\364\266\023\166\102\222\237\125\365"
    "\052\106\033\157\213\353\321\363\217\213\231\104\155\051\064\234"
    "\150\135\207\357\247\060\045\123\334\201\157\164\204\373\254\062"
    "\237\327\156\256\236\255\244\372\041\066\351\206\340\050\240\351"
    "\053\055\162\050\257\265\073\227\040\214\006\241\215\366\312\224"
    "\307\362\224\002\334\014\252\353\272\206\142\356\036\236\363\260"
    "\302\306\223\021\245\347\077\030\130\363\170\223\155\223\320\010"
    "\121\370\116\263\241\063\262\352\122\146\274\171\216\070\041\074"
    "\317\014\361\221\303\045\074\226\215\067\324\246\035\161\016\013"
    "\145\111\275\073\124\303\314\074\343\131\302\141\356\167\110\102"
    "\173\112\156\235\101\334\312\050\172\321\040\375\372\000\207\310"
    "\322\057\253\252\334\056\314\202\127\255\137\066\134\352\324\321"
    "\141\372\265\362\171\143\234\302\346\061\173\163\120\202\310\053"
    "\375\171\010\142\246\026\137\313\256\124\102\220\301\271\133\064"
    "\322\270\136\127\260\221\251\133\245\360\155\107\161\336\262\352"
    "\204\017\304\114\135\333\246\303\351\167\054\231\032\322\176\311"
    "\114\070\233\315\377\035\341\067\001\355\256\026\001\047\051\000"
    "\047\353\152\320\304\276\151\202\016\350\006\312\056\357\300\262"
    "\320\171\335\345\127\057\376\054\126\212\042\041\326\145\023\331"
    "\073\330\076\314\070\141\241\352\302\335\214\317\207\376\110\314"
    "\022\140"
#define      date_z    1
#define      date    ((&data[1517]))
    "\165"
#define      tst1_z    22
#define      tst1    ((&data[1523]))
    "\134\056\004\161\231\074\076\340\211\371\335\315\164\256\327\014"
    "\167\260\315\337\204\061\056\131\040\377\340\144"
#define      tst2_z    19
#define      tst2    ((&data[1548]))
    "\117\262\100\312\020\210\244\220\074\354\067\260\214\323\374\220"
    "\360\137\047\313\105\027\252\113"
#define      inlo_z    3
#define      inlo    ((&data[1570]))
    "\266\272\237"
#define      msg1_z    42
#define      msg1    ((&data[1577]))
    "\052\136\130\360\347\125\064\220\063\037\156\250\362\034\256\341"
    "\273\312\164\113\304\117\336\272\103\201\307\113\157\363\356\333"
    "\347\177\311\041\024\053\116\122\210\341\104\360\311\110\220\345"
    "\373\324\143\344\330"/* End of data[] */;
#define      hide_z    4096
#define DEBUGEXEC    0    /* Define as 1 to debug execvp calls */
#define TRACEABLE    1    /* Define as 1 to enable ptrace the executable */

/* rtc.c */

#include <sys/stat.h>
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

/* 'Alleged RC4' */

static unsigned char stte[256], indx, jndx, kndx;

/*
 * Reset arc4 stte.
 */
void stte_0(void)
{
    indx = jndx = kndx = 0;
    do {
        stte[indx] = indx;
    } while (++indx);
}

/*
 * Set key. Can be used more than once.
 */
void key(void * str, int len)
{
    unsigned char tmp, * ptr = (unsigned char *)str;
    while (len > 0) {
        do {
            tmp = stte[indx];
            kndx += tmp;
            kndx += ptr[(int)indx % len];
            stte[indx] = stte[kndx];
            stte[kndx] = tmp;
        } while (++indx);
        ptr += 256;
        len -= 256;
    }
}

/*
 * Crypt data.
 */
void arc4(void * str, int len)
{
    unsigned char tmp, * ptr = (unsigned char *)str;
    while (len > 0) {
        indx++;
        tmp = stte[indx];
        jndx += tmp;
        stte[indx] = stte[jndx];
        stte[jndx] = tmp;
        tmp += stte[indx];
        *ptr ^= stte[tmp];
        ptr++;
        len--;
    }
}

/* End of ARC4 */

/*
 * Key with file invariants.
 */
int key_with_file(char * file)
{
    struct stat statf[1];
    struct stat control[1];

    if (stat(file, statf) < 0)
        return -1;

    /* Turn on stable fields */
    memset(control, 0, sizeof(control));
    control->st_ino = statf->st_ino;
    control->st_dev = statf->st_dev;
    control->st_rdev = statf->st_rdev;
    control->st_uid = statf->st_uid;
    control->st_gid = statf->st_gid;
    control->st_size = statf->st_size;
    control->st_mtime = statf->st_mtime;
    control->st_ctime = statf->st_ctime;
    key(control, sizeof(control));
    return 0;
}

#if DEBUGEXEC
void debugexec(char * sh11, int argc, char ** argv)
{
    int i;
    fprintf(stderr, "shll=%s\n", sh11 ? sh11 : "<null>");
    fprintf(stderr, "argc=%d\n", argc);
    if (!argv) {
        fprintf(stderr, "argv=<null>\n");
    } else {
        for (i = 0; i <= argc ; i++)
            fprintf(stderr, "argv[%d]=%.60s\n", i, argv[i] ? argv[i] : "<null>");
    }
}
#endif /* DEBUGEXEC */

void rmarg(char ** argv, char * arg)
{
    for (; argv && *argv && *argv != arg; argv++);
    for (; argv && *argv; argv++)
        *argv = argv[1];
}

int chkenv(int argc)
{
    char buff[512];
    unsigned long mask, m;
    int l, a, c;
    char * string;
    extern char ** environ;

    mask  = (unsigned long)&chkenv;
    mask ^= (unsigned long)getpid() * ~mask;
    sprintf(buff, "x%lx", mask);
    string = getenv(buff);
#if DEBUGEXEC
    fprintf(stderr, "getenv(%s)=%s\n", buff, string ? string : "<null>");
#endif
    l = strlen(buff);
    if (!string) {
        /* 1st */
        sprintf(&buff[l], "=%lu %d", mask, argc);
        putenv(strdup(buff));
        return 0;
    }
    c = sscanf(string, "%lu %d%c", &m, &a, buff);
    if (c == 2 && m == mask) {
        /* 3rd */
        rmarg(environ, &string[-l - 1]);
        return 1 + (argc - a);
    }
    return -1;
}

#if !TRACEABLE

#define _LINUX_SOURCE_COMPAT
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

#if !defined(PTRACE_ATTACH) && defined(PT_ATTACH)
#    define PTRACE_ATTACH    PT_ATTACH
#endif
void untraceable(char * argv0)
{
    char proc[80];
    int pid, mine;

    switch(pid = fork()) {
    case  0:
        pid = getppid();
        /* For problematic SunOS ptrace */
#if defined(__FreeBSD__)
        sprintf(proc, "/proc/%d/mem", (int)pid);
#else
        sprintf(proc, "/proc/%d/as",  (int)pid);
#endif
        close(0);
        mine = !open(proc, O_RDWR|O_EXCL);
        if (!mine && errno != EBUSY)
            mine = !ptrace(PTRACE_ATTACH, pid, 0, 0);
        if (mine) {
            kill(pid, SIGCONT);
        } else {
            perror(argv0);
            kill(pid, SIGKILL);
        }
        _exit(mine);
    case -1:
        break;
    default:
        if (pid == waitpid(pid, 0, 0))
            return;
    }
    perror(argv0);
    _exit(1);
}
#endif /* !TRACEABLE */

char * xsh(int argc, char ** argv)
{
    char * scrpt;
    int ret, i, j;
    char ** varg;
    char * me = getenv("_");
    if (me == NULL) { me = argv[0]; }

    stte_0();
     key(pswd, pswd_z);
    arc4(msg1, msg1_z);
    arc4(date, date_z);
    if (date[0] && (atoll(date)<time(NULL)))
        return msg1;
    arc4(shll, shll_z);
    arc4(inlo, inlo_z);
    arc4(xecc, xecc_z);
    arc4(lsto, lsto_z);
    arc4(tst1, tst1_z);
     key(tst1, tst1_z);
    arc4(chk1, chk1_z);
    if ((chk1_z != tst1_z) || memcmp(tst1, chk1, tst1_z))
        return tst1;
    ret = chkenv(argc);
    arc4(msg2, msg2_z);
    if (ret < 0)
        return msg2;
    varg = (char **)calloc(argc + 10, sizeof(char *));
    if (!varg)
        return 0;
    if (ret) {
        arc4(rlax, rlax_z);
        if (!rlax[0] && key_with_file(shll))
            return shll;
        arc4(opts, opts_z);
        arc4(text, text_z);
        arc4(tst2, tst2_z);
         key(tst2, tst2_z);
        arc4(chk2, chk2_z);
        if ((chk2_z != tst2_z) || memcmp(tst2, chk2, tst2_z))
            return tst2;
        /* Prepend hide_z spaces to script text to hide it. */
        scrpt = malloc(hide_z + text_z);
        if (!scrpt)
            return 0;
        memset(scrpt, (int) ' ', hide_z);
        memcpy(&scrpt[hide_z], text, text_z);
    } else {            /* Reexecute */
        if (*xecc) {
            scrpt = malloc(512);
            if (!scrpt)
                return 0;
            sprintf(scrpt, xecc, me);
        } else {
            scrpt = me;
        }
    }
    j = 0;
    varg[j++] = argv[0];        /* My own name at execution */
    if (ret && *opts)
        varg[j++] = opts;    /* Options on 1st line of code */
    if (*inlo)
        varg[j++] = inlo;    /* Option introducing inline code */
    varg[j++] = scrpt;        /* The script itself */
    if (*lsto)
        varg[j++] = lsto;    /* Option meaning last option */
    i = (ret > 1) ? ret : 0;    /* Args numbering correction */
    while (i < argc)
        varg[j++] = argv[i++];    /* Main run-time arguments */
    varg[j] = 0;            /* NULL terminated array */
#if DEBUGEXEC
    debugexec(shll, j, varg);
#endif
    execvp(shll, varg);
    return shll;
}

int main(int argc, char ** argv)
{
#if DEBUGEXEC
    debugexec("main", argc, argv);
#endif
#if !TRACEABLE
    untraceable(argv[0]);
#endif
    argv[1] = xsh(argc, argv);
    fprintf(stderr, "%s%s%s: %s\n", argv[0],
        errno ? ": " : "",
        errno ? strerror(errno) : "",
        argv[1] ? argv[1] : "<null>"
    );
    return 1;
}
